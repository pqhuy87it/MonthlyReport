//
//  AnimationGenerator.swift
//  TestCheckBox
//
//  Created by HuyPQ on 2019/06/26.
//  Copyright Â© 2019 fujitsu. All rights reserved.
//

import Foundation
import UIKit

class AnimationGenerator {
    
    //----------------------------
    // MARK: - Properties
    //----------------------------
    
    // The duration of animations that are generated by the animation manager.
    var animationDuration: TimeInterval = 2.0
    
    // The frame rate for certian keyframe animations.
    fileprivate var frameRate: CGFloat = 60.0
    
    //----------------------------
    // MARK: - Quick Animations
    //----------------------------
    
    final func quickAnimation(_ key: String, reverse: Bool) -> CABasicAnimation {
        let animation = CABasicAnimation(keyPath: key)
        // Set the start and end.
        if !reverse {
            animation.fromValue = 0.0
            animation.toValue = 1.0
            animation.timingFunction = CAMediaTimingFunction(name: .easeIn)
        } else {
            animation.fromValue = 1.0
            animation.toValue = 0.0
            animation.beginTime = CACurrentMediaTime() + (animationDuration * 0.9)
            animation.timingFunction = CAMediaTimingFunction(name: .easeOut)
        }
        // Set animation properties.
        animation.duration = animationDuration / 10.0
        animation.isRemovedOnCompletion = false
        animation.fillMode = CAMediaTimingFillMode.forwards
        
        return animation
    }
    
    /**
     Creates an animation that either quickly fades a layer in or out.
     - note: Mainly used to smooth out the start and end of various animations.
     - parameter reverse: The direction of the animation.
     - returns: A `CABasicAnimation` that animates the opacity property.
     */
    final func quickOpacityAnimation(_ reverse: Bool) -> CABasicAnimation {
        return quickAnimation("opacity", reverse: reverse)
    }
    
    /**
     Creates an animation that either quickly changes the line width of a layer from 0% to 100%.
     - note: Mainly used to smooth out the start and end of various animations.
     - parameter reverse: The direction of the animation.
     - returns: A `CABasicAnimation` that animates the opacity property.
     */
    final func quickLineWidthAnimation(_ width: CGFloat, reverse: Bool) -> CABasicAnimation {
        let animation = quickAnimation("lineWidth", reverse: reverse)
        // Set the start and end.
        if !reverse {
            animation.toValue = width
        } else {
            animation.fromValue = width
        }
        return animation
    }
    
    //----------------------------
    // MARK: - Animation Component Generation
    //----------------------------
    
    final func animation(_ key: String, reverse: Bool) -> CABasicAnimation {
        let animation = CABasicAnimation(keyPath: key)
        // Set the start and end.
        if !reverse {
            animation.fromValue = 0.0
            animation.toValue = 1.0
        } else {
            animation.fromValue = 1.0
            animation.toValue = 0.0
        }
        // Set animation properties.
        animation.duration = animationDuration
        animation.isRemovedOnCompletion = false
        animation.fillMode = CAMediaTimingFillMode.forwards
        animation.timingFunction = CAMediaTimingFunction(name: .easeInEaseOut)
        
        return animation
    }
    
    /**
     Creates an animation that animates the stroke property.
     - parameter reverse: The direction of the animation.
     - returns: A `CABasicAnimation` that animates the stroke property.
     */
    final func strokeAnimation(_ reverse: Bool) -> CABasicAnimation {
        return animation("strokeEnd", reverse: reverse)
    }
    
    /**
     Creates an animation that animates the opacity property.
     - parameter reverse: The direction of the animation.
     - returns: A `CABasicAnimation` that animates the opacity property.
     */
    final func opacityAnimation(_ reverse: Bool) -> CABasicAnimation {
        return animation("opacity", reverse: reverse)
    }
    
    /**
     Creates an animation that animates between two `UIBezierPath`s.
     - parameter fromPath: The start path.
     - parameter toPath: The end path.
     - returns: A `CABasicAnimation` that animates a path between the `fromPath` and `toPath`.
     */
    final func morphAnimation(_ fromPath: UIBezierPath?, toPath: UIBezierPath?) -> CABasicAnimation {
        let animation = CABasicAnimation(keyPath: "path")
        // Set the start and end.
        animation.fromValue = fromPath?.cgPath
        animation.toValue = toPath?.cgPath
        // Set animation properties.
        animation.duration = animationDuration
        animation.timingFunction = CAMediaTimingFunction(name: .easeInEaseOut)
        animation.fillMode = CAMediaTimingFillMode.forwards
        animation.isRemovedOnCompletion = false
        
        return animation
    }
    
    /**
     Creates an animation that animates between a filled an unfilled box.
     - parameter numberOfBounces: The number of bounces in the animation.
     - parameter amplitude: The distance of the bounce.
     - parameter reverse: The direction of the animation.
     - returns: A `CAKeyframeAnimation` that animates a change in fill.
     */
    final func fillAnimation(_ numberOfBounces: Int, amplitude: CGFloat, reverse: Bool) -> CAKeyframeAnimation {
        var values = [CATransform3D]()
        var keyTimes = [Float]()
        
        // Add the start scale
        if !reverse {
            values.append(CATransform3DMakeScale(0.0, 0.0, 0.0))
        } else {
            values.append(CATransform3DMakeScale(1.0, 1.0, 1.0))
        }
        keyTimes.append(0.0)
        
        // Add the bounces.
        if numberOfBounces > 0 {
            for i in 1...numberOfBounces {
                let scale = i % 2 == 1 ? (1.0 + (amplitude / CGFloat(i))) : (1.0 - (amplitude / CGFloat(i)))
                let time = (Float(i) * 1.0) / Float(numberOfBounces + 1)
                
                values.append(CATransform3DMakeScale(scale, scale, scale))
                keyTimes.append(time)
            }
        }
        
        // Add the end scale.
        if !reverse {
            values.append(CATransform3DMakeScale(1.0, 1.0, 1.0))
        } else {
            values.append(CATransform3DMakeScale(0.0001, 0.0001, 0.0001))
        }
        keyTimes.append(1.0)
        
        // Create the animation.
        let animation = CAKeyframeAnimation(keyPath: "transform")
//        animation.values = values.map({ NSValue(caTransform3D: $0) })
        animation.keyTimes = keyTimes.map({ NSNumber(value: $0 as Float) })
        animation.isRemovedOnCompletion = false
        animation.fillMode = CAMediaTimingFillMode.forwards
//        animation.duration = animationDuration
        animation.timingFunction = CAMediaTimingFunction(name: .easeInEaseOut)
        
        return animation
    }
}
